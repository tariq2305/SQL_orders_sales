ğŸ“Š Superstore Monthly Sales & Volume Report

ğŸ“ Project Overview
Welcome to the Superstore SQL Reporting task! This project provides a robust, professional-grade SQL query designed to extract vital business metrics from the Sample_Superstore_Cleaned_UTF8.sql dataset.

Specifically, this README explains how we transformed raw, unformatted order data into a clean, monthly summary report. This report calculates the Total Revenue and Order Volume over specific time periods, giving business stakeholders exactly what they need to analyze seasonal trends and overall performance. ğŸš€

ğŸ—„ï¸ The Database Structure
The data is housed in a single MySQL table named mytable. It contains typical retail transaction columns, but three are crucial for our reporting:

Order_ID: The unique identifier for a customer's purchase.

Order_Date: The date the purchase was made.

Sales: The total revenue generated by the specific items sold.

Challenge unlocked: Our column names contained spaces, and our dates were formatted as strings with two-digit years (e.g., 11/8/17). This required some careful data wrangling! ğŸ•µï¸â€â™‚ï¸

ğŸ› ï¸ The Core SQL Query
To generate a clean monthly timeline, we had to overcome a few SQL hurdles. Here is the final master query you can run directly in your database:

SQL
SELECT 
    DATE_FORMAT(STR_TO_DATE(Order_Date, '%m/%d/%y'), '%Y-%m') AS order_year_month,
    COUNT(DISTINCT Order_ID) AS order_volume,
    SUM(Sales) AS total_revenue
FROM orders_sales
WHERE STR_TO_DATE(Order_Date, '%m/%d/%y') BETWEEN '2017-01-01' AND '2018-12-31'
GROUP BY order_year_month
ORDER BY order_year_month ASC;

ğŸ§© How It Works (Step-by-Step)
Let's break down the magic behind this query:

ğŸ—“ï¸ Fixing the Dates (STR_TO_DATE & DATE_FORMAT):
Because the raw dates looked like '11/8/17', MySQL couldn't group them naturally out of the box. We used STR_TO_DATE(..., '%m/%d/%y') to teach the database how to read the string as a real, valid date. Then, DATE_FORMAT(..., '%Y-%m') transformed it into a clean YYYY-MM format (like 2017-11), which is perfect for monthly grouping.

ğŸ“¦ Calculating True Order Volume (COUNT(DISTINCT)):
Customers often buy multiple items at once, meaning the exact same Order ID appears on multiple rows. By using COUNT(DISTINCT \Order ID`)`, we made sure to count each unique order only once. This gives us the true volume of shopping carts checked out, rather than just the number of individual line items sold.

ğŸ’° Calculating Total Revenue (SUM):
We simply used the SUM(Sales) function to add up the revenue for all items sold within that specific month.

â±ï¸ Filtering the Timeline (WHERE):
We added a WHERE clause using the BETWEEN operator. This acts as a gatekeeper, allowing you to limit the report to a specific time period (in our example, a custom date range) before the data gets aggregated.

ğŸ—‚ï¸ Grouping & Sorting (GROUP BY & ORDER BY):
Finally, we clustered all the matching rows by our new order_year_month column. The ORDER BY ... ASC clause ensures that our final report is neatly sorted in chronological order, from oldest to newest. ğŸ“ˆ

ğŸ’¡ How to Customize for Your Needs
You can easily tweak this query to answer different business questions:

Find Your Best Months: Change ORDER BY order_year_month ASC to ORDER BY total_revenue DESC. This will instantly bring your most profitable months to the top of the list!

Find Your Busiest Months: Change the sorting to ORDER BY order_volume DESC to see when the warehouse was working the hardest.

Isolate a Specific Year: Swap out the BETWEEN operator and use WHERE YEAR(STR_TO_DATE(\Order Date`, '%m/%d/%y')) = 2018` to view data for a single year.
